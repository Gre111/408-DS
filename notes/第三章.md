# 第三章

## 3.1 栈

**1.定义**

Stack 特殊的线性表（只允许从一端插入或删除

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-03-00-26-08-image.png" alt="" width="357" data-align="inline">

- 空栈、栈顶、栈底

- 特点：后进先出（LIFO

**2.操作（函数定义**

```c
InitStack(&S)     //初始化栈，为空
DestroyStack(&L)  //销毁 
Push(&S, x)       //进栈 
Pop(&S, &x)       //出栈，逻辑上删顶
GetTops(S, &x)    //读取栈顶元素，逻辑上不删顶
StackEmpty(S)     //判断是否为空
```

3.**常见题型** 

（1）判断是否为合法的出栈顺序？ notes：进栈和出栈操作同时进行

**4.零碎：**

初始化栈、清空栈在逻辑上只需要使top=-1

两个栈共享一个数组，一个从低地址增长，一个从高地址递减。

    `top0 = top1 +1 `  //栈满

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-03-18-16-05-image.png" alt="" data-align="left" width="72">

#### 顺序栈代码实现

```c
// 顺序栈定义
#define MaxSize 10         //最大元素个数 
typedef struct{
	ElemType data[MaxSize]; 
	int top;               //栈顶指针
} SqStack;


//初始化栈
void InitStack(SqStack &S){
	S.top = -1;             //初始为-1（有影响）
}


//入栈
bool Push(SqStack &S, ElemType x){
	if(S.top == MaxSize-1)  //栈满
		return false;
	S.data[++S.top] = x;    //指向栈顶元素
	return true;
}


//出栈
bool Pop(SqStack &S, ElemType &x){
	if(S.top == -1)
		return false;
	x = S.data[S.top--];
	return true;
}


//读取栈顶
bool GetTops(SqStack S, ElemType &x){
	if(S.top == -1)
		return false;
	x = S.data[S.top];
	return true;
}

```

#### 链栈代码实现

```c
// 链栈的定义
typedef struct Linknode{
	ElemType data;
	struct Linknode *next;
}LNode, *LiStack;

//初始化
bool InitStack(LiStack &S){  //不带头节点
	S = Null;
	return true;
}

//进栈
bool push(LiStack &S, ElemType x){
	LNode *s = (LNode*)malloc(sizeof(LNode));
	s->next = S.next;
	S.next = s;
	s->data = x;
	return true;
}

//出栈
bool pop(LiStack &S, ElemType &x){
	LNode *s = S.next;
	x = s->data;
	S.next = s->next;
	return true;
}

//读取栈顶
bool GetTops(LiStack S, ElemType &x){
	LNode *s = S.next;
	x = s->data;
	return true;
}
```

## 3.2 队列 Queue

**1.定义**

只允许在一端插入（队尾），另一端删除（对头）

特点：先进先出FIFO

**2.操作**

```c
InitQueue(&Q)       //初始化，为空
DestroyQueue(&Q)    //销毁队列
EnQueue(&Q)         //入队
DeQueue(&Q, &x)     //出队
GetHead(Q, &x)      //读取对头元素
```

**3.循环队列**

通过Mod运算将队列在逻辑上变为环状

<img title="" src="file:///C:/Users/jia'le/AppData/Roaming/marktext/images/2024-07-03-18-02-20-image.png" alt="" width="273" data-align="inline">

队列满的判断： `(rear+1)%MaxSize == front`

队列空的判断： `rear == front`
